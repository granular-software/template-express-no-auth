# Zod Schema Design for MCP Servers

## Schema-First Development

Zod schemas are the foundation of your MCP server. They define data validation, type safety, and AI agent understanding.

## Basic Schema Patterns

### Simple Entity Schema
```typescript
const ProductSchema = z.object({
  id: z.string().readonly(),           // Auto-generated, read-only
  name: z.string().min(1, "Name is required"),
  description: z.string().optional(),
  price: z.number().positive("Price must be positive"),
  category: z.string().min(1, "Category is required"),
  createdAt: z.date().readonly(),      // Auto-set, read-only
  updatedAt: z.date().readonly(),      // Auto-updated, read-only
});

type Product = z.infer<typeof ProductSchema>;
```

### Complex Nested Schema
```typescript
const CategorySchema = z.object({
  id: z.string().readonly(),
  name: z.string().min(1, "Category name is required"),
  description: z.string().optional(),
  parentId: z.string().optional(), // Self-referencing for hierarchy
  metadata: z.object({
    color: z.string().optional(),
    icon: z.string().optional(),
    sortOrder: z.number().default(0),
  }).default({}),
  createdAt: z.date().readonly(),
});

const ProductSchema = z.object({
  id: z.string().readonly(),
  name: z.string().min(1, "Name is required"),
  description: z.string().optional(),
  price: z.number().positive("Price must be positive"),
  categoryId: z.string().min(1, "Category is required"),
  tags: z.array(z.string()).default([]),
  metadata: z.object({
    sku: z.string().optional(),
    weight: z.number().positive().optional(),
    dimensions: z.object({
      length: z.number().positive().optional(),
      width: z.number().positive().optional(),
      height: z.number().positive().optional(),
    }).optional(),
    images: z.array(z.string().url()).default([]),
  }).default({}),
  createdAt: z.date().readonly(),
  updatedAt: z.date().readonly(),
});
```

## Schema Validation Patterns

### Input Validation Schemas
```typescript
// Separate schemas for different operations
const CreateProductSchema = ProductSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

const UpdateProductSchema = CreateProductSchema.partial(); // All fields optional

const ProductQuerySchema = z.object({
  name: z.string().optional(),
  categoryId: z.string().optional(),
  priceMin: z.number().positive().optional(),
  priceMax: z.number().positive().optional(),
  tags: z.array(z.string()).optional(),
  inStock: z.boolean().optional(),
  limit: z.number().min(1).max(100).default(20),
  offset: z.number().min(0).default(0),
});

// Use in handlers
create: {
  description: "Create a new product",
  inputSchema: CreateProductSchema,
  handler: async (data) => {
    // data is fully validated and typed
    const product = await createProduct(data);
    return product;
  },
},

search: {
  description: "Search products with filters",
  inputSchema: ProductQuerySchema,
  handler: async (query) => {
    // query is validated with defaults applied
    return await searchProducts(query);
  },
}
```

### Advanced Validation
```typescript
const ProductSchema = z.object({
  id: z.string().readonly(),
  name: z.string()
    .min(1, "Name is required")
    .max(200, "Name must be less than 200 characters")
    .trim(),
  description: z.string()
    .max(2000, "Description must be less than 2000 characters")
    .optional(),
  price: z.number()
    .positive("Price must be positive")
    .max(999999.99, "Price must be reasonable"),
  categoryId: z.string().min(1, "Category is required"),
  tags: z.array(z.string())
    .max(20, "Maximum 20 tags allowed")
    .transform(tags => tags.map(tag => tag.toLowerCase().trim())),
  status: z.enum(["active", "inactive", "discontinued"])
    .default("active"),
  metadata: z.record(z.unknown()).optional(), // Flexible metadata
  createdAt: z.date().readonly(),
  updatedAt: z.date().readonly(),
});
```

## Schema Relationships

### Referential Integrity
```typescript
const CategorySchema = z.object({
  id: z.string().readonly(),
  name: z.string().min(1, "Category name is required"),
  description: z.string().optional(),
  parentId: z.string().optional(),
  createdAt: z.date().readonly(),
});

const ProductSchema = z.object({
  id: z.string().readonly(),
  name: z.string().min(1, "Name is required"),
  price: z.number().positive("Price must be positive"),
  categoryId: z.string().min(1, "Category is required"),
  createdAt: z.date().readonly(),
  updatedAt: z.date().readonly(),
});

// Validate relationships exist
const validateProductRelations = async (data: z.infer<typeof ProductSchema>) => {
  const category = await db.categories.findById(data.categoryId);
  
  if (!category) throw new Error("Category not found");
  
  return { category };
};
```

### Polymorphic Relationships
```typescript
const AttachmentSchema = z.object({
  id: z.string().readonly(),
  filename: z.string().min(1, "Filename is required"),
  mimeType: z.string().min(1, "MIME type is required"),
  size: z.number().positive("File size must be positive"),
  url: z.string().url("Invalid URL"),
  entityType: z.enum(["product", "category", "manufacturer"]),
  entityId: z.string().min(1, "Entity ID is required"),
  createdAt: z.date().readonly(),
});

// Validate entity exists based on type
const validateAttachmentEntity = async (data: z.infer<typeof AttachmentSchema>) => {
  let entity;
  
  switch (data.entityType) {
    case "product":
      entity = await db.products.findById(data.entityId);
      break;
    case "category":
      entity = await db.categories.findById(data.entityId);
      break;
    case "manufacturer":
      entity = await db.manufacturers.findById(data.entityId);
      break;
    default:
      throw new Error("Invalid entity type");
  }
  
  if (!entity) throw new Error(`${data.entityType} not found`);
  return entity;
};
```

## Schema Transformation and Coercion

### Data Transformation
```typescript
const ProductInputSchema = z.object({
  name: z.string().min(1).transform(name => name.trim()),
  description: z.string().optional().transform(desc => desc?.trim()),
  price: z.coerce.number().positive().max(999999.99), // Coerce string to number
  categoryId: z.string().min(1),
  tags: z.string().transform(str => str.split(',').map(tag => tag.trim())),
  metadata: z.string().transform(str => JSON.parse(str)), // Coerce JSON string
});

// Use in handler
handler: async (rawData) => {
  // Transform and validate input
  const data = ProductInputSchema.parse(rawData);
  
  // data is now properly typed and transformed
  const product = await createProduct(data);
  return product;
}
```

### Conditional Validation
```typescript
const ProductSchema = z.object({
  id: z.string().readonly(),
  name: z.string().min(1),
  price: z.number().positive(),
  categoryId: z.string().min(1),
  status: z.enum(["active", "inactive", "discontinued"]),
  
  // Conditional fields based on status
  discontinuedAt: z.date().optional().refine(
    (discontinuedAt) => {
      // Discontinued products must have discontinuation date
      return status !== "discontinued" || discontinuedAt !== undefined;
    },
    { message: "Discontinued products require discontinuation date" }
  ),
  
  // High-value products have additional requirements
  highValue: z.object({
    insurance: z.boolean().default(false),
    warranty: z.number().positive("Warranty must be positive"),
    specialHandling: z.boolean().default(false),
  }).optional().refine(
    (highValue) => {
      return price < 1000 || highValue !== undefined;
    },
    { message: "High-value products require additional information" }
  ),
});
```

## Schema Composition and Reuse

### Base Schemas
```typescript
const BaseEntitySchema = z.object({
  id: z.string().readonly(),
  createdAt: z.date().readonly(),
  updatedAt: z.date().readonly(),
});

const AuditableSchema = BaseEntitySchema.extend({
  createdBy: z.string().min(1),
  updatedBy: z.string().min(1),
  version: z.number().positive(),
});

// Extend base schemas
const CategorySchema = AuditableSchema.extend({
  name: z.string().min(1),
  description: z.string().optional(),
  parentId: z.string().optional(),
  // ... other category fields
});

const ProductSchema = AuditableSchema.extend({
  name: z.string().min(1),
  price: z.number().positive(),
  categoryId: z.string().min(1),
  // ... other product fields
});
```

### Schema Merging
```typescript
const CreateProductSchema = ProductSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  createdBy: true,
  updatedBy: true,
  version: true,
});

const UpdateProductSchema = CreateProductSchema.partial();

// Merge with additional validation
const CreateProductWithValidationSchema = CreateProductSchema.merge(
  z.object({
    confirmCreation: z.boolean().refine(
      (confirm) => confirm === true,
      { message: "Must confirm product creation" }
    ),
    termsAccepted: z.boolean().refine(
      (accepted) => accepted === true,
      { message: "Must accept terms and conditions" }
    ),
  })
);
```

## Best Practices

1. **Descriptive Error Messages**: Use clear, actionable error messages
2. **Schema Composition**: Build complex schemas from simple, reusable parts
3. **Input/Output Separation**: Use different schemas for input validation vs output
4. **Relationship Validation**: Always validate that referenced entities exist
5. **Type Safety**: Leverage TypeScript inference for compile-time safety
6. **Performance**: Use `.transform()` for expensive operations, `.refine()` for validation
7. **Documentation**: Use `.describe()` for AI agent understanding
8. **Default Values**: Provide sensible defaults where appropriate
9. **Coercion**: Use `.coerce` for safe type conversions
10. **Testing**: Test your schemas with various input scenarios
description: Zod schema design patterns and best practices for MCP servers
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: false
---
description:
globs:
alwaysApply: false
---
